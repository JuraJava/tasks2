/**
 * Что происходит:
 * В программе два потока — reader и writer.
 * - writer устанавливает number = 42, затем ready = true.
 * - reader в цикле проверяет флаг ready и при его истинности присваивает локальной переменной local значение number,
 * после чего выводит его.
 * - В main сначала запускается reader, затем главный поток засыпает на 10 мс, после чего запускается writer.
 * Проблема:
 * Переменные ready и number не объявлены как volatile и не защищены другими механизмами синхронизации. Это означает,
 * что компилятор или процессор могут переупорядочить операции записи в потоке writer (например, ready = true может
 * выполниться до number = 42 из-за оптимизаций). Кроме того, изменения, сделанные в одном потоке, могут быть не сразу
 * видны другому потоку из-за отсутствия  happens-before  гарантий.
 *
 * Что может быть выведено:
 * Возможны следующие варианты:
 * 1.	0 — если поток reader не увидит изменение ready (из-за отсутствия синхронизации) за все 100 миллионов итераций,
 * либо если ready стало true, но number осталось 0 (переупорядочение записи ready перед number).
 * 2.	42 — если оба значения корректно видны и порядок записи сохранён.
 * 3.	42,  но с задержкой — если reader увидит ready = true после запуска writer.
 * Наиболее вероятный вывод в консоль:
 * 0, потому что:
 * - Поток reader стартует первым и начинает проверять ready, которое изначально false.
 * - Через 10 мс запускается writer, но даже если он быстро выполнится, reader может не увидеть изменения ready из-за
 * кэширования в локальной памяти потока (проблема видимости).
 * - Цикл в reader выполняется 100 миллионов раз — этого может быть недостаточно, чтобы дождаться ready = true из-за
 * отсутствия синхронизации.
 *
 * Оптимальное исправление:
 * Объявить переменные как volatile, чтобы гарантировать видимость изменений и запретить переупорядочение операций записи:
 * static volatile boolean ready;
 * static volatile int number;
 * Тогда вывод гарантированно будет 42 (при условии, что reader дождётся ready = true).
 */

package org.example;

public class MultiThread {
//  Изначально было так:
  static boolean ready;
  static int number;

//    //    Далее предложено оптимизировать
//    static volatile boolean ready;
//    static volatile int number;

    public static void main(String[] args) throws InterruptedException {
        Thread writer = new Thread(() -> {
            number = 42;
            ready = true;
        });

        Thread reader = new Thread(() -> {
            int local = 0;
            for (int i = 0; i < 100_000_000; i++) {
                if (ready) {
                    local = number;
                    break;
                }
            }
            System.out.println("number = " + local);
        });

        reader.start();
        Thread.sleep(10);
        writer.start();

        reader.join();
        writer.join();
    }
}
